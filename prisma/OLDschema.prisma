/* generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Role {
  id              String            @id @default(cuid())
  code            String            @unique // machine code (what we filter on): "member" | "competition" | "officer" | "president" | "alumni"
  name            String // human label (what we show)
  profiles        ProfileRole[]
  EventAccessRole EventAccessRole[]
}

model ProfileRole {
  profileId String
  roleId    String

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  role    Role    @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([profileId, roleId])
  @@index([roleId])
}

model Profile {
  id             String        @id @default(uuid())
  userId         String        @unique
  handle         String        @unique
  displayName    String
  avatarUrl      String?
  bio            String?
  iRating        Int?
  socials        Json?
  marketingOptIn Boolean       @default(true)
  status         ProfileStatus @default(active)

  roles ProfileRole[]

  duesPaid   Boolean   @default(false)
  duesPaidAt DateTime?
  major      String?

  eid        String?  @unique
  gradYear   Int?
  signedUpAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  eventsCreated Event[]        @relation("EventCreatedBy")
  eventsHosted  Event[]        @relation("EventHostProfile")
  rsvps         EventRSVP[]
  checkins      EventCheckin[]
  invites       EventInvite[]

  resultsCreated EventResult[]      @relation("EventResultCreatedBy")
  resultEntries  EventResultEntry[] @relation("EventResultEntryProfile")
}

model Venue {
  id           String  @id @default(uuid())
  name         String
  addressLine1 String?
  addressLine2 String?
  city         String?
  state        String?
  postalCode   String?
  country      String?
  room         String?
  geo          Json?

  events    Event[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Event {
  id           String  @id @default(uuid())
  slug         String  @unique
  title        String
  summary      String?
  description  String?
  heroImageUrl String?

  startsAtUtc DateTime // <- plain DateTime; store UTC values only
  endsAtUtc   DateTime
  timezone    String // IANA tz to render local time correctly

  status EventStatus @default(draft)

  rsvpRequired    Boolean   @default(false)
  rsvpOpenAt      DateTime?
  rsvpCloseAt     DateTime?
  capacity        Int?
  waitlistEnabled Boolean   @default(true)

  venueId            String?
  venue              Venue?  @relation(fields: [venueId], references: [id], onDelete: SetNull)
  meetingUrl         String?
  streamUrl          String?
  dialIn             String?
  accessInstructions String?

  createdByProfileId String
  createdByProfile   Profile @relation("EventCreatedBy", fields: [createdByProfileId], references: [id], onDelete: Restrict)
  hostProfileId      String
  hostProfile        Profile @relation("EventHostProfile", fields: [hostProfileId], references: [id], onDelete: Restrict)

  requiresDuesPaid Boolean           @default(false)
  accessRoles      EventAccessRole[]
  invites          EventInvite[]

  rsvps    EventRSVP[]
  checkins EventCheckin[]

  publishedAt        DateTime?
  embargoUntil       DateTime?
  updatedByProfileId String?
  updatedAt          DateTime  @updatedAt
  createdAt          DateTime  @default(now())

  results EventResult[]

  @@index([status, startsAtUtc])
  @@index([startsAtUtc])
}

model EventAccessRole {
  eventId String
  roleId  String

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  role  Role  @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([eventId, roleId])
  @@index([roleId])
}

model EventInvite {
  eventId   String
  profileId String
  note      String?

  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@id([eventId, profileId])
  @@index([profileId])
}

model EventRSVP {
  id          String     @id @default(uuid())
  eventId     String
  profileId   String
  status      RSVPStatus
  waitlistPos Int?
  respondedAt DateTime   @default(now())

  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([eventId, profileId])
  @@index([eventId, status, respondedAt])
  @@index([eventId, waitlistPos])
}

model EventCheckin {
  id          String   @id @default(uuid())
  eventId     String
  profileId   String
  checkedInAt DateTime @default(now())
  method      String?

  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([eventId, profileId])
  @@index([eventId])
}

enum ProfileStatus {
  active
  retired
  deleted
}

enum EventStatus {
  draft
  scheduled
  in_progress
  canceled
  postponed
  completed
}

enum RSVPStatus {
  yes
  waitlist
  no
  canceled
}

enum SessionType {
  qualifying
  race
}

enum FinishStatus {
  finished
  dnf
  dns
  dsq
}

enum ResultStatus {
  draft
  provisional
  official
}

model EventResult {
  id                 String       @id @default(uuid())
  eventId            String
  type               SessionType
  status             ResultStatus @default(draft) // draft → provisional → official
  notes              String?
  source             String? // e.g. "manual", or future: "iracing"
  createdByProfileId String
  officialAt         DateTime? // when marked official

  event            Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  createdByProfile Profile @relation("EventResultCreatedBy", fields: [createdByProfileId], references: [id], onDelete: Restrict)

  entries EventResultEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, type]) // one quali + one race per event
  @@index([eventId, status])
}

model EventResultEntry {
  id            String       @id @default(uuid())
  resultId      String
  profileId     String? // null = guest
  displayName   String // show this on the table (pre-fill from Profile if set)
  position      Int? // 1-based; null if not classified
  status        FinishStatus @default(finished)
  lapsCompleted Int?
  totalTimeMs   Int? // accept "hh:mm:ss.mmm" in UI; store ms here
  bestLapMs     Int?
  gapToP1Ms     Int?
  notes         String?

  result  EventResult @relation(fields: [resultId], references: [id], onDelete: Cascade)
  profile Profile?    @relation("EventResultEntryProfile", fields: [profileId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([resultId, profileId]) // allows multiple NULLs for guests; prevents dup members
  @@index([resultId, position])
}
*/
