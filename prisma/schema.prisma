// ---------- Generators & Datasource ----------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ---------- Enums ----------
enum EventStatus {
  draft
  scheduled
  in_progress
  canceled
  postponed
  completed
}

enum UserStatus {
  active
  pending_verification
  retired
  deleted
}

enum Visibility {
  public
  members
  officers
}

enum EventType {
  meeting
  practice
  race
  workshop
  social
}

enum RSVPStatus {
  going
  waitlist
  canceled
}

enum CheckinMethod {
  qr
  manual
  import
}

enum SessionKind {
  practice
  qual
  race
}

enum FinishStatus {
  finished
  dnf
  dns
  dsq
}

enum ResultSource {
  manual
  stracker
  import
}

enum PaymentProvider {
  stripe
  manual
  other
}

enum PaymentStatus {
  succeeded
  pending
  failed
  refunded
}

enum ProductType {
  ANNUAL_DUES
  LEAGUE_FEE
}

enum EntitlementKind {
  lsr_member
  league_access
}

enum EntitlementScope {
  year
  season
  lifetime
}

enum AuditAction {
  create
  update
  delete
  import
  login
  logout
  rsvp
  checkin
  payment_success
  payment_failed
  profile_update
}

// ---------- Identity & Access ----------
model User {
  id             String     @id @default(uuid())
  email          String     @unique
  handle         String     @unique
  displayName    String
  avatarUrl      String?
  bio            String?
  iRating        Int?
  socials        Json?
  marketingOptIn Boolean    @default(true)
  status         UserStatus @default(active)

  major      String?
  gradYear   Int?
  eid        String?  @unique
  signedUpAt DateTime @default(now())

  // Relations
  authIdentities         AuthIdentity[]
  roles                  UserRole[]
  payments               Payment[]
  entitlements           Entitlement[]
  memberships            UserMembership[]
  posts                  Post[]           @relation("PostAuthor")
  pages                  Page[]           @relation("PageAuthor")
  RSVPs                  RSVP[]
  checkins               Attendance[]
  entries                Entry[]          @relation("EntryUser")
  auditLogs              AuditLog[]       @relation("AuditActor")
  provenanceCreated      Provenance[]     @relation("ProvenanceCreatedBy")
  importArtifactsCreated ImportArtifact[] @relation("ImportArtifactCreatedBy")
  mediaOwned             Media[]          @relation("MediaOwner")
  rawResultUploads       RawResultUpload[]
  driverIdentities       DriverIdentity[]
  raceParticipants       RaceParticipant[]


  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}


model Role {
  id          String @id @default(uuid())
  key         String @unique // "admin" | "officer" | "member"
  description String

  users                 UserRole[]
  eligibilityMinRoleFor EventEligibility[] @relation("EligibilityMinRole") // <-- back-relation for min role gate
}

model UserRole {
  userId String
  roleId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@id([userId, roleId])
  @@index([roleId])
}

model AuthIdentity {
  id             String @id @default(uuid())
  userId         String
  provider       String
  providerUserId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([provider, providerUserId])
  @@index([userId])
}

model AuditLog {
  id          String  @id @default(uuid())
  actorUserId String?
  ip          String?
  userAgent   String?

  entityType String
  entityId   String
  action     AuditAction
  diffJson   Json?
  metaJson   Json?

  actor User? @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([entityType, entityId, createdAt])
  @@index([createdAt])
}

// ---------- Membership, Dues & Fees ----------
model MembershipTier {
  id    String @id @default(uuid())
  key   String @unique // "GENERAL", "LSR_MEMBER"
  label String

  users UserMembership[]
}

model UserMembership {
  id        String    @id @default(uuid())
  userId    String
  tierId    String
  validFrom DateTime
  validTo   DateTime?

  user User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  tier MembershipTier @relation(fields: [tierId], references: [id], onDelete: Cascade)

  @@unique([userId, tierId, validFrom])
  @@index([userId, validTo])
}

model Product {
  id          String      @id @default(uuid())
  type        ProductType
  name        String
  leagueId    String?
  amountCents Int
  currency    String      @default("USD")
  active      Boolean     @default(true)
  metadata    Json?

  league   League?   @relation("EntitlementLeague", fields: [leagueId], references: [id], onDelete: SetNull) // named to match Entitlement.league
  payments Payment[]

  @@unique([type, leagueId])
  @@index([leagueId])
}

model Payment {
  id          String          @id @default(uuid())
  userId      String
  productId   String
  amountCents Int
  currency    String          @default("USD")
  provider    PaymentProvider
  providerRef String?
  status      PaymentStatus
  paidAt      DateTime?
  metadata    Json?
  createdAt   DateTime        @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  entitlements Entitlement[]

  @@index([userId, productId, status, paidAt])
}

model Entitlement {
  id              String           @id @default(uuid())
  userId          String
  kind            EntitlementKind
  leagueId        String?
  scope           EntitlementScope
  validFrom       DateTime
  validTo         DateTime?
  sourcePaymentId String?
  meta            Json?

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  league  League?  @relation("EntitlementLeague", fields: [leagueId], references: [id], onDelete: SetNull) // <-- named & back-rel on League
  payment Payment? @relation(fields: [sourcePaymentId], references: [id], onDelete: SetNull)

  @@index([userId, kind, leagueId, validTo])
  @@index([leagueId])
}

// ---------- Leagues & Competition ----------
model League {
  id            String     @id @default(uuid())
  name          String
  slug          String     @unique
  descriptionMd String?
  visibility    Visibility @default(public)

  seasons              Season[]
  classes              Class[]
  products             Product[]          @relation("EntitlementLeague")
  entitlements         Entitlement[]      @relation("EntitlementLeague") // <-- back-relation
  eventEligibilityRefs EventEligibility[] @relation("EligibilityLeague") // <-- back-relation for event gate
}

model Season {
  id         String     @id @default(uuid())
  leagueId   String?
  seriesId   String?
  name       String
  slug       String     @unique
  year       Int
  startAt    DateTime?
  endAt      DateTime?
  pointsRule Json?
  visibility Visibility @default(public)

  league  League?  @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  series  EventSeries? @relation(fields: [seriesId], references: [id], onDelete: SetNull)
  rounds  Round[]
  entries Entry[]

  @@index([leagueId, year])
  @@index([seriesId])
}

model Round {
  id       String   @id @default(uuid())
  seasonId String
  name     String
  slug     String   @unique
  date     DateTime
  eventId  String?  @unique // <-- enforce 1:1 when present

  season   Season    @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  event    Event?    @relation("EventRound", fields: [eventId], references: [id], onDelete: SetNull) // <-- named relation
  sessions Session[]

  @@index([seasonId, date])
}

model Session {
  id          String      @id @default(uuid())
  roundId     String
  kind        SessionKind
  trackId     String?
  carId       String?
  classId     String?
  laps        Int?
  durationMin Int?
  startedAt   DateTime?

  round Round  @relation(fields: [roundId], references: [id], onDelete: Cascade)
  track Track? @relation(fields: [trackId], references: [id], onDelete: SetNull)
  car   Car?   @relation(fields: [carId], references: [id], onDelete: SetNull)
  class Class? @relation(fields: [classId], references: [id], onDelete: SetNull)

  results Result[]

  @@index([roundId, kind])
}

model Class {
  id       String @id @default(uuid())
  leagueId String
  name     String
  slug     String @unique

  league   League    @relation(fields: [leagueId], references: [id], onDelete: Cascade)
  entries  Entry[]
  sessions Session[]

  @@index([leagueId])
}

model Team {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())

  entries Entry[]
}

model Entry {
  id               String  @id @default(uuid())
  seasonId         String
  userId           String?
  teamId           String?
  classId          String?
  carId            String?
  number           Int?
  nickname         String?
  isEligiblePoints Boolean @default(true)

  // Aggregated Stats (Computed)
  totalPoints   Int     @default(0)
  roundsCounted Int     @default(0)
  totalCuts     Int     @default(0)
  totalCollisions Int   @default(0)
  starts        Int     @default(0)
  wins          Int     @default(0)
  podiums       Int     @default(0)
  top5          Int     @default(0)
  top10         Int     @default(0)
  bestFinish    Int?
  averageFinish Float?
  dnfs          Int     @default(0)
  rank          Int?

  carDisplay    String?

  season Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  user   User?  @relation("EntryUser", fields: [userId], references: [id], onDelete: SetNull)
  team   Team?  @relation(fields: [teamId], references: [id], onDelete: SetNull)
  class  Class?  @relation(fields: [classId], references: [id], onDelete: Restrict)
  car    Car?   @relation(fields: [carId], references: [id], onDelete: SetNull)

  results Result[]

  @@unique([seasonId, classId, userId], map: "unique_entry_user")
  @@index([seasonId, classId])
}

model Result {
  id            String       @id @default(uuid())
  sessionId     String
  entryId       String
  position      Int?
  points        Int?
  bestLapMs     Int?
  totalTimeMs   Int?
  lapsCompleted Int?
  status        FinishStatus @default(finished)
  penaltiesJson Json?
  source        ResultSource @default(manual)
  provenanceId  String?

  session    Session     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  entry      Entry       @relation(fields: [entryId], references: [id], onDelete: Cascade)
  provenance Provenance? @relation(fields: [provenanceId], references: [id], onDelete: SetNull) // <-- make relation optional

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sessionId, entryId])
  @@index([sessionId, position])
}

model Provenance {
  id            String       @id @default(uuid())
  source        ResultSource
  payloadSha256 String
  notes         String?
  createdById   String?
  createdAt     DateTime     @default(now())

  createdBy User?            @relation("ProvenanceCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  artifacts ImportArtifact[]
  results   Result[]

  @@index([source, createdAt])
}

model ImportArtifact {
  id           String   @id @default(uuid())
  storageUrl   String
  contentType  String
  bytes        Int
  createdById  String?
  provenanceId String? // <-- proper FK to Provenance
  createdAt    DateTime @default(now())

  createdBy  User?       @relation("ImportArtifactCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  provenance Provenance? @relation(fields: [provenanceId], references: [id], onDelete: SetNull)

  @@index([createdAt])
}

// ---------- Tracks & Cars ----------
model Track {
  id      String  @id @default(uuid())
  name    String
  layout  String?
  country String?
  lengthM Int?
  simKey  String? @unique

  sessions Session[]
}

model Car {
  id        String  @id @default(uuid())
  name      String
  simKey    String? @unique
  classHint String?

  sessions Session[]
  entries  Entry[]
}

// ---------- Events & Eligibility ----------
model EventSeries {
  id         String     @id @default(uuid())
  title      String
  slug       String     @unique
  visibility Visibility @default(public)

  events    Event[]
  seasons   Season[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Venue {
  id           String  @id @default(uuid())
  name         String
  addressLine1 String?
  addressLine2 String?
  city         String?
  state        String?
  postalCode   String?
  country      String?
  room         String?
  geo          Json?

  events    Event[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Event {
  id           String  @id @default(uuid())
  seriesId     String?
  venueId      String?
  slug         String  @unique
  title        String
  roundNumber  Int?
  summary      String?
  description  String?
  heroImageUrl String?

  startsAtUtc DateTime
  endsAtUtc   DateTime
  timezone    String

  visibility Visibility  @default(public)
  status     EventStatus @default(scheduled)

  rsvpRequired    Boolean   @default(false)
  rsvpOpenAt      DateTime?
  rsvpCloseAt     DateTime?
  capacity        Int?
  waitlistEnabled Boolean   @default(true)

  meetingUrl         String?
  streamUrl          String?
  dialIn             String?
  accessInstructions String?

  series EventSeries? @relation(fields: [seriesId], references: [id], onDelete: SetNull)
  venue  Venue?       @relation(fields: [venueId], references: [id], onDelete: SetNull)

  eligibility EventEligibility?
  rsvps       RSVP[]
  checkins    Attendance[]

  rawResultUploads RawResultUpload[]
  ingestedSessions RaceSession[]

  round Round? @relation("EventRound") // <-- match Round.event

  publishedAt DateTime?
  updatedAt   DateTime  @updatedAt
  createdAt   DateTime  @default(now())

  @@index([startsAtUtc])
  @@index([status, startsAtUtc])
}

model EventEligibility {
  eventId           String  @id
  allowsGeneral     Boolean @default(true)
  requiresLsrMember Boolean @default(false)
  requiresLeagueId  String?
  minRoleId         String?
  eligibilityJson   Json?

  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  league  League? @relation("EligibilityLeague", fields: [requiresLeagueId], references: [id], onDelete: SetNull) // <-- named & back-rel
  minRole Role?   @relation("EligibilityMinRole", fields: [minRoleId], references: [id], onDelete: SetNull) // <-- named & back-rel

  @@index([requiresLeagueId])
  @@index([minRoleId])
}

model RSVP {
  id          String     @id @default(uuid())
  eventId     String
  userId      String
  status      RSVPStatus
  waitlistPos Int?
  respondedAt DateTime   @default(now())
  source      String     @default("web")

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId, status, respondedAt])
  @@index([eventId, waitlistPos])
}

model Attendance {
  id          String         @id @default(uuid())
  eventId     String
  userId      String
  checkedInAt DateTime       @default(now())
  method      CheckinMethod?

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
}

// ---------- Content (light CMS) ----------
model Post {
  id          String     @id @default(uuid())
  title       String
  slug        String     @unique
  excerpt     String?
  bodyMd      String
  authorId    String? // <-- optional because onDelete: SetNull
  publishedAt DateTime?
  visibility  Visibility @default(public)

  author    User?    @relation("PostAuthor", fields: [authorId], references: [id], onDelete: SetNull)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Page {
  id         String     @id @default(uuid())
  title      String
  slug       String     @unique
  bodyMd     String
  visibility Visibility @default(public)
  authorId   String?

  author    User?    @relation("PageAuthor", fields: [authorId], references: [id], onDelete: SetNull)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Media {
  id         String  @id @default(uuid())
  title      String?
  storageUrl String
  width      Int?
  height     Int?
  alt        String?
  ownerId    String?

  owner User? @relation("MediaOwner", fields: [ownerId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id   String @id @default(uuid())
  name String
  slug String @unique

  entities EntityTag[]
}

// NOTE: Prisma canâ€™t enforce a polymorphic relation back to Post/Page/etc.
// Keep `entityType` + `entityId` as loose FKs and query manually.
model EntityTag {
  id         String @id @default(uuid())
  tagId      String
  entityType String // e.g. "post","page","event","league","season",...
  entityId   String

  tag Tag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@index([entityType, entityId])
  @@index([tagId])
}

model FeatureFlag {
  id      String  @id @default(uuid())
  key     String  @unique
  enabled Boolean @default(false)
}

model GalleryImage {
  id        String   @id @default(uuid())
  publicId  String   @unique
  alt       String?
  creditName String?
  creditUrl  String?
  order     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum RawResultUploadStatus {
  UPLOADED
  PARSED
  INGESTED
  FAILED
}


model RawResultUpload {
  id               String                  @id @default(uuid())
  filename         String
  filesize         Int
  sha256           String
  rawJson          Json
  uploadedByUserId String
  uploadedAt       DateTime                @default(now())
  status           RawResultUploadStatus   @default(UPLOADED)
  errorMessage     String?
  parseReport      ParseReport?

  uploadedBy       User                    @relation(fields: [uploadedByUserId], references: [id])
  eventId          String?
  pointsSystem     String? // "F1", "NONE"
  event            Event?                  @relation(fields: [eventId], references: [id])

  ingestedSessions RaceSession[]

  @@index([uploadedByUserId])
  @@index([eventId])
}


model DriverIdentity {
  id           String   @id @default(uuid())
  driverGuid   String   @unique
  lastSeenName String
  userId       String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id])
}

model CarMapping {
  id                   String   @id @default(uuid())
  gameCarName          String   @unique
  displayName          String
  secondaryDisplayName String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  participants RaceParticipant[]
}

model RaceSession {
  id          String   @id @default(uuid())
  uploadId    String
  eventId     String?
  
  // Session details from JSON
  sessionType String // "RACE", "QUALIFYING", "PRACTICE"
  trackName   String
  trackConfig String?
  startedAt   DateTime
  pointsSystem String? // "F1", "NONE", etc.
  
  upload RawResultUpload @relation(fields: [uploadId], references: [id], onDelete: Cascade)
  event  Event?          @relation(fields: [eventId], references: [id])

  participants RaceParticipant[]
  results      RaceResult[]
  laps         RaceLap[]
  events       RaceEvent[]
  
  @@index([uploadId])
  @@index([eventId])
}

model RaceParticipant {
  id            String @id @default(uuid())
  sessionId     String
  driverGuid    String
  displayName   String
  carName       String
  carClass      String
  teamName      String?
  
  // New fields from "Cars"
  carIdInSession Int?    // The "CarId" (0, 1, 2...)
  nation         String?
  skin           String?
  ballastKg      Int?
  restrictor     Int?
  
  session RaceSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  userId        String?
  user          User?           @relation(fields: [userId], references: [id])
  
  carMappingId  String?
  carMapping    CarMapping?     @relation(fields: [carMappingId], references: [id])
  
  results RaceResult[]
  laps    RaceLap[]
  
  eventsAsPrimary RaceEvent[] @relation("EventPrimary")
  eventsAsOther   RaceEvent[] @relation("EventOther")

  @@unique([sessionId, driverGuid])
}

model RaceResult {
  id            String @id @default(uuid())
  sessionId     String
  participantId String
  
  position      Int
  classPosition Int
  bestLapTime   Int? // ms
  totalTime     Int? // ms
  lapsCompleted Int
  status        String // "Finished", "DNF", etc.
  gap           String? 
  
  // New fields from "Result"
  points         Int?
  totalCuts      Int?
  collisionCount Int?
  penaltyTime    Int?
  lapPenalty     Int?
  isDisqualified Boolean @default(false)
  
  session     RaceSession     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  participant RaceParticipant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  @@index([sessionId])
}

model RaceLap {
  id            String @id @default(uuid())
  sessionId     String
  participantId String
  
  lapNumber     Int
  lapTime       Int // ms
  sector1       Int? // ms
  sector2       Int? // ms
  sector3       Int? // ms
  valid         Boolean @default(true)
  
  // New fields from "Laps"
  cuts      Int?
  tyre      String?
  timestamp Int? // Session timestamp
  
  session     RaceSession     @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  participant RaceParticipant @relation(fields: [participantId], references: [id], onDelete: Cascade)

  @@index([sessionId, participantId])
}

model RaceEvent {
  id            String @id @default(uuid())
  sessionId     String
  type          String // "COLLISION_WITH_CAR", "COLLISION_WITH_ENV"
  
  carId         Int?
  driverGuid    String?
  participantId String?
  
  otherCarId      Int?
  otherDriverGuid String?
  otherParticipantId String?
  
  impactSpeed   Float
  
  worldPosX     Float?
  worldPosY     Float?
  worldPosZ     Float?
  
  relPosX       Float?
  relPosY       Float?
  relPosZ       Float?
  
  session          RaceSession      @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  participant      RaceParticipant? @relation("EventPrimary", fields: [participantId], references: [id])
  otherParticipant RaceParticipant? @relation("EventOther", fields: [otherParticipantId], references: [id])

  @@index([sessionId])
}


model ParseReport {
  id              String          @id @default(uuid())
  uploadId        String          @unique
  drivers         Json
  resultsCount    Int
  lapsCount       Int
  anomalies       String[]
  createdAt       DateTime        @default(now())

  upload          RawResultUpload @relation(fields: [uploadId], references: [id], onDelete: Cascade)
}

